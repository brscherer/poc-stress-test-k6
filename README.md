# PoC Stress Test with k6

This project demonstrates how to perform stress testing on a simple Node.js/Express ToDo CRUD API using [k6](https://k6.io/). The API itself is a basic in-memory ToDo list, but the main focus here is on how to use k6 for load and stress testing.

## Project Structure

- `src/server.js`: The Express server implementing the ToDo CRUD API (in-memory storage).
- `src/stress-test.js`: The k6 script used to stress test the API.
- `package.json`: Project configuration and scripts.

## Running the Project

### 1. Install Dependencies

This project uses [pnpm](https://pnpm.io/) as the package manager. Install dependencies with:

```bash
pnpm install
```

### 2. Start the API Server

Start the Express server (with nodemon for auto-reload):

```bash
pnpm dev
```

The server will run locally (default: `http://localhost:3000`).

### 3. Run the k6 Stress Test

In a separate terminal, run:

```bash
pnpm test
```

This will execute the `src/stress-test.js` script using k6, simulating multiple users and requests against the API.

## About the k6 Stress Test

- The k6 script (`src/stress-test.js`) is designed to simulate concurrent users performing CRUD operations on the ToDo API.
- You can customize the number of virtual users, duration, and request patterns by editing the k6 script.
- k6 provides detailed metrics on response times, error rates, and throughput, helping you identify performance bottlenecks.

### Example k6 Script Features

- Simulates multiple users (virtual users, VUs)
- Sends HTTP requests to the API endpoints (create, read, update, delete ToDos)
- Measures response times and error rates
- Can be extended to include ramping up/down users, thresholds, and more

### Tests Results

```bash
brscherer@Animus:~/poc-stress-test-k6$ pnpm run test

> poc-stress-test-k6@1.0.0 test /home/brscherer/poc-stress-test-k6
> k6 run src/stress-test.js


         /\      Grafana   /‾‾/
    /\  /  \     |\  __   /  /
   /  \/    \    | |/ /  /   ‾‾\
  /          \   |   (  |  (‾)  |
 / __________ \  |_|\_\  \_____/

     execution: local
        script: src/stress-test.js
        output: -

     scenarios: (100.00%) 1 scenario, 200 max VUs, 2m30s max duration (incl. graceful stop):
              * default: Up to 200 looping VUs for 2m0s over 3 stages (gracefulRampDown: 30s, gracefulStop: 30s)



  █ THRESHOLDS

    # PoC Stress Tests with k6

    This repository contains two small proof-of-concept (PoC) stress tests implemented with k6 that demonstrate two common concurrency-related issues in Node.js services:

    - A memory leak introduced by retaining buffers in a long-lived array (`src/leak.js` + `src/leak-test.js`).
    - A race condition caused by unsafe updates to shared in-memory state (`src/race.js` + `src/race-test.js`).

    These tests are intentionally small and unsafe to make the issues easy to reproduce locally.

    ## Project structure (relevant files)

    - `src/leak.js` — Express app that allocates and keeps a 50KB buffer on every `/data` request (memory leak demo).
    - `src/leak-test.js` — k6 script that repeatedly hits `/data` and writes `leak-summary.html` via `handleSummary`.
    - `src/race.js` — Express app with a non-atomic increment endpoint `/increment` (race demo) and `/value` to read the counter.
    - `src/race-test.js` — k6 script that posts to `/increment` concurrently and writes `race-summary.html` via `handleSummary`.
    - `leak-summary.html`, `race-summary.html` — HTML reports generated by the k6 reporter (created by the k6 scripts when run).
    - `package.json` — contains a `dev` script (starts `src/leak.js` with nodemon) and a `test` script that currently runs the leak test.

    ## Quick start

    1. Install dependencies:

    ```bash
    pnpm install
    ```

    2. Run one of the demo servers and the corresponding k6 script in a second terminal. See below for each PoC.

    Notes:
    - k6 is invoked directly by the k6 scripts (they use an external reporter to generate HTML). You can run k6 via `pnpm test` (which currently runs the leak test), or call k6 directly for a specific script: `k6 run src/race-test.js`.
    - `nodemon` is included; `pnpm dev` will run `src/leak.js` for the leak demo. For the race demo you can run `node src/race.js` or use `nodemon` manually.

    ## Memory-leak PoC

    Purpose: demonstrate how retaining buffers can cause the process memory to grow under sustained load.

    Files:
    - `src/leak.js` — server listening on port `4000`.
    - `src/leak-test.js` — k6 script that hits `GET http://localhost:4000/data`.

    Run the leak demo:

    Terminal 1 — start the server:

    ```bash
    pnpm dev            # starts src/leak.js on port 4000 (uses nodemon)
    # OR: node src/leak.js
    ```

    Terminal 2 — run the k6 script (this will generate `leak-summary.html` in the repo):

    ```bash
    # package.json 'test' currently points to the leak test
    pnpm test
    # OR run directly if you have k6 installed: k6 run src/leak-test.js
    ```

    What to look for:
    - Watch the Node process memory (e.g., `ps`/Activity Monitor). You should see memory steadily increase while the test runs.
    - Open `leak-summary.html` after the test for k6 metrics and request-level timings.

    ## Race-condition PoC

    Purpose: demonstrate lost updates due to non-atomic read-modify-write on shared in-memory state under concurrency.

    Files:
    - `src/race.js` — server listening on port `3000` with `/increment` and `/value`.
    - `src/race-test.js` — k6 script that posts to `/increment` concurrently and writes `race-summary.html`.

    Run the race demo:

    Terminal 1 — start the race server:

    ```bash
    node src/race.js
    # OR with nodemon: npx nodemon src/race.js
    ```

    Terminal 2 — run the k6 script:

    ```bash
    k6 run src/race-test.js
    # (This will produce `race-summary.html` in the repo)
    ```

    What to look for:
    - After the k6 run, call `GET http://localhost:3000/value` to read the final counter. With 100 concurrent VUs posting for several seconds you will likely observe a final count much lower than the total number of increments attempted (lost updates).
    - `race-summary.html` contains the k6 metrics.

    ## Interpreting the reports

    - `*-summary.html` files are generated by the `handleSummary` function in each k6 script using the external reporter and contain request/response metrics, errors, and thresholds.
    - For the leak PoC, focus on external process memory (OS-level) instead of request timeouts — the demo intentionally retains memory on each request.
    - For the race PoC, compare the attempted number of increments (k6 iterations * VUs) vs the observed counter returned by the `/value` endpoint.

    ## Troubleshooting

    - If a k6 script fails to connect, make sure the corresponding demo server is running on the expected port (4000 for leak, 3000 for race).
    - If `pnpm test` runs the wrong test, call k6 directly: `k6 run src/leak-test.js` or `k6 run src/race-test.js`.
    - On macOS you can watch the Node process memory with Activity Monitor or from the terminal:

    ```bash
    ps -o pid,comm,%mem,etime | grep node
    ```

    ## Notes and next steps

    - These PoCs are intentionally minimal. To harden the demos:
      - Fix the leak by not retaining per-request large buffers or by using streaming where possible.
      - Fix the race by using an atomic/shared lock, external datastore (e.g., Redis) or by serializing updates.
    - Consider adding dedicated npm scripts for running each k6 test and for starting the race server with nodemon.

    ---

    If you'd like, I can add npm scripts for `race:dev`, `leak:dev`, `test:leak`, and `test:race`, and wire `pnpm test` to run both tests in sequence or via a flag.
